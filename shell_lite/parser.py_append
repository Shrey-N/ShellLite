
    def parse_increment(self) -> Assign:
        token = self.consume('INCREMENT')
        name = self.consume('ID').value
        amount = Number(1)
        if self.check('BY'):
            self.consume('BY')
            amount = self.parse_expression()
        self.consume('NEWLINE')
        node = Assign(name, BinOp(VarAccess(name), '+', amount))
        node.line = token.line
        return node

    def parse_decrement(self) -> Assign:
        token = self.consume('DECREMENT')
        name = self.consume('ID').value
        amount = Number(1)
        if self.check('BY'):
            self.consume('BY')
            amount = self.parse_expression()
        self.consume('NEWLINE')
        node = Assign(name, BinOp(VarAccess(name), '-', amount))
        node.line = token.line
        return node

    def parse_multiply(self) -> Assign:
        token = self.consume('MULTIPLY')
        name = self.consume('ID').value
        self.consume('BY')
        amount = self.parse_expression()
        self.consume('NEWLINE')
        node = Assign(name, BinOp(VarAccess(name), '*', amount))
        node.line = token.line
        return node

    def parse_divide(self) -> Assign:
        token = self.consume('DIVIDE')
        name = self.consume('ID').value
        self.consume('BY')
        amount = self.parse_expression()
        self.consume('NEWLINE')
        node = Assign(name, BinOp(VarAccess(name), '/', amount))
        node.line = token.line
        return node

    def parse_set(self) -> Assign:
        token = self.consume('SET')
        name = self.consume('ID').value
        self.consume('TO')
        value = self.parse_expression()
        self.consume('NEWLINE')
        node = Assign(name, value)
        node.line = token.line
        return node

    def parse_sum(self) -> Node:
        token = self.consume('SUM')
        self.consume('OF')
        
        # Check for 'numbers from ...'
        if self.check('NUMBERS'):
             range_node = self.parse_numbers_range()
             # range_node is Call('range_list', ...)
             # We want Call('sum', [range_node])
             node = Call('sum', [range_node])
             node.line = token.line
             return node
             
        expr = self.parse_expression()
        node = Call('sum', [expr])
        node.line = token.line
        return node

    def parse_upper(self) -> Node:
        token = self.consume('UPPER')
        expr = self.parse_expression()
        only_letters = Boolean(False)
        if self.check('ONLY'):
            self.consume('ONLY')
            if self.check('LETTERS'):
                self.consume('LETTERS')
            only_letters = Boolean(True)
        node = Call('upper', [expr, only_letters])
        node.line = token.line
        return node

    def parse_numbers_range(self) -> Node:
        token = self.consume('NUMBERS')
        self.consume('FROM')
        start = self.parse_expression()
        self.consume('TO')
        end = self.parse_expression()
        
        condition = None
        if self.check('THAT'):
            self.consume('THAT')
            self.consume('ARE')
            if self.check('PRIME'):
                self.consume('PRIME')
                condition = String('prime')
            elif self.check('DIGITS'):
                self.consume('DIGITS')
                condition = String('digits')
        elif self.check('WHEN'):
             self.consume('WHEN')
             # 'when even' -> check for ID 'even' or expression?
             # User example: 'when even'. Implicit variable?
             # Let's verify repro: 'when even'
             if self.check('ID') and self.peek().value == 'even':
                 self.consume()
                 condition = String('even')
             elif self.check('ID') and self.peek().value == 'odd':
                 self.consume()
                 condition = String('odd')
             else:
                 # TODO: handle generic expression filter if needed
                 pass
                 
        node = Call('range_list', [start, end, condition if condition else Boolean(False)])
        node.line = token.line
        return node
